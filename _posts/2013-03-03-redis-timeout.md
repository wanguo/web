---
layout: post
title: "Redis 超时问题总结"
date: 2013-03-03 11:15
category: "Tech"
tags: [Redis]
---
{% include JB/setup %}

### 网络延迟

redis是基于TCP/IP协议进行通信的，任何的网络不稳定都可能造成超时。所以要尽量减少和redis的交互次数，减少网络来往次数来减少有网络本身带来的延迟。

### Redis的单线程处理方式

Redis使用单线程来处理所有命令，也就是说所有命令是按顺序进行的。但是redis不会阻塞系统调用，比如socket的系统调用，redis分别实现了linux存在的三种io模式：epoll、poll和select。注：redis在bgsave和AOF rewrite的时候会fork出子进程来处理，以及在redis2.4版本之后，redis会使用多线程来处理和IO相关的慢操作，但是保持单线程处理所有命令的模式仍然不变。因此redis不适合在单核的机器上跑。

### 慢命令

因为redis的单线程处理方式，所以一个命令如果慢了的话，其他的命令就只能等待这个命令结束才能继续了，虽然redis大部分命令都会非常快，但是也有少数命令是会比较耗时的，比如：sort，union一个大的set，就会非常的耗时。所以一定要尽量避免慢命令的使用。

### Fork子进程

Fork子进程在linux下是一个相当消耗的操作，尤其是需要做虚拟内存到物理内存的映射运算会消耗大量的时间和CPU，主要是因为在linux下内存按页分配，默认大小每页4k，这样的话为一个24G大小的redis实例fork一个子进程需要主动分配24G/4k * 8 = 48M的空间。解决办法是使用大页管理的内存分配，这个在最新的linux 2.6.12以后已经支持。如果使用老版本的linux也可以通过给系统打补丁来实现。

### 系统使用SWAP

如果系统还运行了其他应用，消耗了较大内存，导致系统使用了swap分区，会导致redis超时。
